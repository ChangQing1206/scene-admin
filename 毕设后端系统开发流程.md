# 毕设后端系统开发流程

***基于物联网的景区游客管理系统，具体实现以下功能：***

***1.电子门票：将RFID技术应用于景区电子门票，实现出票、验票（门禁）、计票等功能。可实现景区“一卡通”功能（选做），游客对电子门票充值后，可以在景区内进行餐饮、旅游项目、购物等一切消费活动。***

***2.定位跟踪：将GPS/北斗定位技术用于游客的定位跟踪，在游客求助时可以迅速确定游客的位置，及时提供帮助；可以对各景点的客流量进行统计，结合电子地图，对景点拥堵的概率、时段和程度进行预报。***

***3.电子围栏：结合电子地图，在重点建筑、景区边界等处设置电子围栏，当游客越过电子围栏时会向游客发出提示信息，并向景区工作人员发出报警信息，以保证景区内人身、财产安全性。***

***4.体温检测：实时监测游客体温，当体温出现异常时，向景区管理处发出报警信息。***

***5.一键求助：游客遇有紧急情况需要帮助时，可以通过终端节点一键求助按键，向景区管理处进行求助。***

***6.数据记录与查询：可以记录和查询近几天游客的相关信息，包括游客基本信息、体温、游览景点数据等。***

***7.完成系统软硬件设计、安装与调试。***

***8.按要求撰写毕业设计论文，完成其它相关任务。*** 

## 技术栈：express + mongodb + ES6 + MD5

### 功能需求

#### 登录注册、历史记录查询、喜好分析

#### 1.创建项目

1.https://blog.csdn.net/weixin_42490398/article/details/90212418  

先创建github仓库，然后在本地目录git init  本地与远程仓库连接   git remote add *yourf仓库name* *git_url*

拉取远程仓库到本地 git pull scene-admin main   编写代码，提交到本地仓库  git commit -m "first commit"

2.先进入项目根目录，npm init 生成package.json 文件  然后npm install express --save  安装express框架

然后npx express-generator 安装骨架生成器

3.安装mongoose 相当于sequelize  npm install mongoose --save

4.安装加密 encryto command: npm install encryto --save  安装 formidable   安装 time-formater  安装 express-session 

5.mosca的backend可选redis,mongo等，其实现选择了ascoltatori进行了redis，Mongo等适配兼容。于是下载了ascoltatori的源码查看了mongo部分的源码，发现其实现是使用了mongodb的固定集合。固定集合的特点是事先决定了该集合的文档数，容量大小，以及如果超出了容量，则最新数据覆盖掉最早的数据，类似循环队列。源码里面的设定的文档条数是10000条，最大容量是10MB.根据任务书第六条，<u>数据记录与查询：可以记录和查询近几天游客的相关信息，包括游客基本信息、体温、游览景点数据等</u>。 如果按照每个游客一分钟更新一次数据，一天景区接待游客3000个，景区开放时长8个小时，则一天产生的数据量：1 * 60 * 8 * 3000 = 1440000 条数据 假如数据需要查询近3天的，则需要保存三天的数据 5120000条数据。所以还是**在mosca server里面操作mongo比较好。 mosca 还可以采用集成方式放在express里面 ，这其实跟之前通过http请求，进而发起socket连接类似**。

6.将mosca server集成到express 。定义 mosca 暴露 server  将数据插入  查询时聚合查询 索引查询 

MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果 

使用limit 完成分页查询 

#### 2.历史记录查询及喜好分析

1.游客数据查询

- 显示：游客姓名、游客性别、游客体温、游客日期。编辑操作，删除操作。展开后，还有消费过的商品。经纬度生成路径，到过的景点。
- 一页20条数据，也就是20个游客。
- 可以按天查询，数据库只保存了近5天的数据。因为物联网数据的海量性，决定了不可能长时间保存。

2.游客位置分析

分析出游客的景点路径，游客去过的景点次数，停留时间

3.游客消费分析

游客喜欢消费的商品，游客消费最多的价格区间

#### 3.喜好分析的问题

1.游客消费的记录不应该有游客上传，而是由商家设备上传

消费设备通过wifi模块直接上传游客消费记录至express服务器api，api将数据写入消费表

2.单独一个vue组件用于显示游客消费的数据记录【类似订单列表】

这里不需要聚合查询  两种查询方法 

3.保留消费分析，位置分析的功能

### 流程重构

1.游客设备启动，连接mqtt服务器
　　一旦有人来购票，首先启动一个游客设备，设备自动连接服务器。clientId由设备端自己生成并保存。连接服务器后，设备就提示连接成功同时订阅生成门票的topic，之后向售票客户端发送可以出票了的信息。接下来管理员就可以在售票系统中输入门票信息了。
2.门票管理之售票系统生成门票
　　售票系统往设备订阅的生成门票的主题发送数据。需要提供的数据有：游客姓名[不再作为查询依据，哪怕是需要查询某个游客的情况]，游客身份证[作为游客查询依据，唯一标识]，测量游客的体温，位置采取默认值.  以身份证作为唯一标识，不用担心游客姓名的重复。售票系统这里作为一个mqtt客户端。注意：因为需要验票，而且电子门票应该有三个状态：未使用，使用中，已报废，所以在售票时还需要提供一个门票状态的数据。同时它应该展示在售票统计中。【完成出票功能】

17.门票管理之售票统计

​	售票系统在出票后同时向express服务器发起post请求，将门票信息存储至数据库。所以售票统计中可以查看所有已售门票的信息，并且可以按天查询。这样可以让管理员了解一天的销量。【完成任务书的计票功能】

15.验票系统

​	当游客进入景区之前，需要验票才能进入。所以需要验票设备。验票设备获取游客设备的电子标签信息，验证门票的状态，如果是未使用，才能进入，并且将门票的状态改变为使用中。同时上传后端系统api，api插入数据库，当离开景区后，游客的门票状态则改变为已报废【完成验票功能】

3.开始循环上报数据
　　client.on(message) 保存数据，取消订阅生成门票，写入电子标签。再订阅一些控制主题【提醒游客已进入危险区域，或者某某景点，路段拥堵情况，销毁游客数据等】。此时还不能开启循环上报，必须监控平台早已订阅了创建游客模型，更新游客模型，销毁游客模型等。设备首先往创建游客模型主题【公共主题 无clientId】发了内容，告诉监控平台创建游客模型。接着开始循环上报数据至更新游客模型主题。【实现是在mosca服务器进行数据库的上传，还是在接收的时候上传，如果在前端上传，将会发起大量的http请求，将会消耗前端性能，所以还是在mqtt服务器上传，可以考虑使用主题来实现识别】
4.处理游客紧急求助
　　这个不属于游客定时上报数据的一部分。当游客按下设备的紧急求助键时，按键应该要使用中断触发，一旦触发，立刻调用client.publish()  ，监控平台在这之前已经完成了紧急处理主题的订阅。这里不需要对游客进行单一连接，所以这样即可。监控平台判断是否是紧急处理的主题信息，然后前端语音播放xx紧急求助，位置是xx。同时，监控平台上该游客的点变红【方便管理员查看位置】。【完成游客一键求助功能】

19.监控平台之按身份证锁定游客及特定消息通知【即是按向某个游客发送通知】

​	此功能便于查找某个游客的情况。且根据需要通知游客。

20.监控平台之体温异常

​	三种思路：1.在监控平台的更新游客模型时检测  2.在硬件端检测  3.在数据到达监控平台时检测

后两者时间上差距不大，如果采取硬件端检测，这需要在增加一个主题，会增大mqtt服务器的压力，同时为了提高实时性，则使用第三种方案。一旦数据到达监控平台，在更新游客数据函数中顺便检测体温是否异常。如果异常，语音播放。同时监控平台该游客的点变黄。【如果需要寻找密切接触者，则计算这个游客与其他游客的同一时间点的距离】

21.监控平台之密切接触者

​	当监控平台检测出某个游客体温异常时，监控平台自动计算密切接触者，并弹出排列好的密切接触者的信息。同时有操作按钮，通知这些密切接触者，返回景区入口。

5.监控平台之电子围栏
        监控平台使用了高德地图和对应的api，管理员可以设置景区电子围栏，禁区电子围栏。监控平台更新的频率太快了会影响性能，考虑到真实情况，监控平台5分钟更新一次，游客两分钟更新一次。游客每次更新的记录都被保存到了mongo数据库。在监控平台更新时，同时检查游客的位置是否位于景区电子围栏，或者禁区电子围栏。而且还会检查游客的体温。以上动作有反应的话，监控平台立刻通知游客设备。通知的方法：这里需要明确两个字段的区别，mqtt clientId 和  游客身份证。 mqtt clientId只用于传输层识别，游客身份证用于应用层识别【完成电子围栏功能】

```javascript
mqtt——clientId的作用
例如，在监控平台检测到游客处于景区电子围栏时，监控平台需要通知游客设备，怎么通知，需要用到clientId,游客在未进入循环上报之前，订阅了该游客进入景点的通知主题。这个主题是唯一的，只适合这个游客，保证每个游客唯一性的方法就是在主题中应用clientId
clientId不必每次都传送，

注意：体温异常不仅需要通知游客，还需要通知管理员。即直接this.$message({type: 'warning', message: vistor.name + vistor.idenfication + position + '体温异常' + vistor.bodyTem})
游客身份证的作用

```

6.增加的功能
       距离测试，设置地图显示范围【附加功能】
7.数据管理之游客数据查询
       这个查询查的是每个游客的姓名，身份证，最高体温记录，体温记录（用于生成体温变化图），时间记录等(游客游玩的日期可从时间记录中得到) [想要在设备端组装这些数据不太可能，所以可以考虑在接收处处理，拦截器]

8.充值系统
    	为了促使游客充值，仅在入口处管理员这里才可以充值。同时，剩下的钱可以在出口处管理员这里退还。所以就需要两个管理员。mqtt和express早就启动了，管理员登录管理系统立刻观察。充值系统的流程是，在出票后，管理员询问是否需要充值，而且出去后可以退还。游客选择充值的话，管理员在充值页面进行输入，需要的数据有身份证，姓名，充值金额。[设备之前就已经订阅了自己的充值主题]点击确认后，充值系统先根据身份证向服务器请求拿到这个游客的id，用于组装出这个游客的充值主题，有了游客对应的充值主题就可以往特定的充值主题发送数据进行充值了。充值系统在充值时还订阅了该游客的充值响应主题，用于了解是否充值成功，设备一旦接收到自己订阅的充值主题的数据，就会立刻往充值响应主题发送响应状态，即是充值成功或者失败。充值系统拿到对应的响应状态后提醒管理员是否充值成功，同时将这个充值状态，和之前的姓名，身份证，还有金额，以及生成一个时间，同时存到数据库。



##### 设备状态是一个非常重要的变量：它可以被用来判断各种情况。比如充值时，如果设备的状态是未启用，则不应该充值。充值是在充值系统中填写信息，然后发送至游客设备。如果发送成功【但在这里，如果设备未启用，则发送也不会失败，因为mqtt 服务器能顺利接收】，则充值成功。经过测试，哪怕设备未开启，也会充值成功。

解决方法1：使用设备状态

解决方法2：timeout 增加充值响应部分。



9.数据管理之充值记录查询 

```javascript
 Model.aggregate([{$match: {size: 'medium'}}, {$group: {_id: "$name", totalQuantity: { $sum: "$quantity" }}}])  // 先匹配，再分组 统计中等尺寸各种品种的披萨的数量
```

​	为了使管理员了解游客的充值情况，在数据管理模块的充值记录查询功能可以对游客的充值记录进行查询，查询的方式有两种，顺序查询和按游客查询。前面充值系统往数据库塞的数据有：姓名，身份证，充值金额，充值时间，充值状态，顺序查询即直接从数据库拿这些记录，注意要分页。按游客查询，即是聚合查询，聚合查询有个问题就是顺序问题，为了确保聚合后的数据有顺序，因为分页显示需要有顺序，所以将聚合结果做时间排序。

```javascript
db.express_info.aggregate([{$match:{"mobile":"18663930231"}},{$group : {_id : "$express_code",date_time:{$first:"$datetime"},express_code:{$first:"$express_code"}, num_tutorial : {$sum : 1}}},{$sort:{"datetime":-1}},{$skip:5},{$limit:5}])
```

充值记录查询组件有两个标签，默认正常显示即是顺序显示，顺序显示时，按照时间排序，保证分页。点击游客显示，即进行聚合查询。改变的是数据源，因为按照聚合查询后的结果是：游客姓名，游客身份证，游客充值金额记录，游客充值时间记录，游客充值状态记录。由聚合的过程可知，三个数组是一一对应的。

10.消费系统

​	这里又涉及到硬件端。消费设备需要跟游客设备进行交互。游客设备的电子标签被消费设备感应，商家根据游客购买的商品，选择对应商品【价格已经确定】，选择数量，计算费用，读取电子标签的剩余金额【电子标签内部存在一个剩余金额变量，每次充值剩余金额加上充值金额，初始为0】，如果剩余金额大于费用，扣费成功，电子标签的剩余金额减去费用，消费设备上传消费数据：游客姓名，游客身份证，游客消费的商品名称，游客消费的金额，游客消费的数量，游客的剩余金额，游客的支付状态，【游客消费的时间】可以考虑服务器生成。消费设备上传数据的通道是，直接post提交到express api

11.数据管理之消费记录查询

​	为了使管理员能够了解游客的消费情况，在数据管理模块的消费记录查询功能可以对游客的消费情况进行查询。查询的方式有两种，顺序查询和按游客查询。前面消费系统往数据库塞的数据有：游客姓名，游客身份证，游客消费的商品名称，商品单价，游客消费的数量，游客的剩余金额，游客的支付状态，游客消费的时间。

```javascript
ConsumeModel = {
    name, // 姓名
    identification, // 身份证
    goodsName, // 商品名称
    goodsNum, // 商品数量
    goodsPrice, // 商品单价
    dateTime, // 购买时间
    status, // 支付状态
    curDeposit // 剩余金额
}
```

12.数据管理之消费分析

​	为了使管理员了解最热门的商品或服务，统计各类商品的消费占比。使用echarts饼图实现。

```javascript
[{value: 12, name: '火腿肠'} , {value: 4, name: '鸡翅'} , {value: 2， name: '钓鱼'}]
// 怎么查询 统计各类商品的数量
数据源：消费表 
查询操作：ConsumeModel.aggregate([
    {$group: {_id: "$goodsName", totalNum: {$sum: "$goodsNum"}}}
])
[
    {
    	goodsName: '火腿肠',
   		totalNum: 12
    },
    {
        goodsName: '鸡翅',
        totalNum: 4
    },
    {
        goodsName: '钓鱼',
        totalNum: 2
    }
]
```

13.数据管理之游客数据查询

​	为了使管理员能够查看游客的历史数据：这里只提供按游客查询，因为这个数据不像消费记录和充值记录一样，它太多了，直接查看某条游客数据意义不大，所以只按游客查询，这样还可以查看一些关键信息。它提供的数据包括：

```javascript
VistorModel = {
    //clientId, // 设备id
    name,	// 姓名
    idenfication,	// 身份证
    bodyTem,	// 体温数组
//    bodyTemMax,	// 最高体温
    position,	// 位置数组  用于显示游客的路径
    dateTime,   // 时间数组 【这是一个时间数组，但是我需要展示的是日期，时间数组用于体温变化图】
}
游客数据库模型



展开行显示体温变化 el-table
去过的景点怎么实现：就是在提醒游客进入的时候，同时上传到后端

1.创建游客模型时发送的数据包括clientId
设备端发送信息至创建游客topic
创建游客的信息
{
    clientId,
    identity,
    name,
    bodyTem,
    position,
    create_time // 在mqtt server生成
}
vistor = {clientId: {identity, name, bodyTem, position}}

然后，在更新游客的信息时，需要使用到clientId找游客  
所以更新时需要上传的信息仅有：clientId, bodyTem, position, 
游客信息的插入不能在前端

```

14.数据管理之位置分析【景点游玩历史查询】  

​	为了不浪费空间【一开始就不应该使用mongoose】，重新考虑位置分析功能。直接不要这个功能，改为游览路径查询。为管理员展示：游客姓名，游客身份证，游客去过的景点，停留的时长，进入时间，离开时间。

```javascript
{
    name: xx,
    identity: xx,
    scenePoint:
    {
        enter_time: xx,
        leave_time: xx,
        time_length: xx
    }
}
```

18.监控平台之景点客流量统计，对景点拥堵的概率、时段和程度进行预报

在监控平台更新时，会判断游客进入了是否进入了景点。这时候，可以使用一个这样的数据结构来表示

```javascript
[{scenePoint1: [vistor1, vistor2, vistor3...]}, {scenePoint2: [vistor10, vistor12...]}]
上述结构用于记录每个景点的游客。什么时候预报？就在监控平台更新时预报。怎样预报？因为这个是对所有游客的通知，所以这个是公共信息，意味着每个游客都有订阅一个这样的主题： /mqtt/vistor/public 监控平台将信息发送至这个主题。 怎样计算拥堵概率？利用游客的数量以及停留时间【该景点游客停留的平均时长】计算拥堵概率。
拥堵即是超出景点的最大容量。假设景点的最大容量maxSize是100人。当现有游客人数达到最大容量的百分之八十。则根据游客的停留时长，未来一个小时将会达到最大容量。这时候提示未来一个小时会出现拥堵的概率是：拥堵概率取决于   当前游客人数，中位数停留时长，游客流入时速，游客流出时速。
首先，一个景点的游客流速只能通过数据分析，它应该趋于一个稳定值，而且停留时长中位数也是一个稳定值，所以综上，出现拥堵概率只取决于当前游客人数/景点最大游客容量。 如果能对游客的流速和停留时长随时分析，那么拥堵概率为： 拥堵概率 = (当前游客 + （游客流入时速-游客流出时速）*1【因为预报按照一个小时来预测】) / 游客最大容量   例如：某景点游客最大容量为100， 当前游客人数为50，游客流速为10，那么未来一小时出现拥堵概率为60%。
最终实现的效果：在监控平台上可以观察到相应景区电子围栏的人数【完成客流量统计功能】。监控平台还会通报，
https://tts.youdao.com/fanyivoice?word={text}&le=zh&keyfrom=speaker-target	使用有道api text就是要预报的内容 当前xx景点游客人数为xx,10点半到11点半时段，预计拥堵概率为70% 
监控平台还将信息发送给游客设备，当有新消息发送至游客设备，游客设备会哔一声，显示在lcd屏幕上【完成对景点拥堵概率、时段和程度的预报的功能】

```



### 通信通道汇总





