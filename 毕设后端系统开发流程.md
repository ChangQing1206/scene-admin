# 毕设后端系统开发流程

***基于物联网的景区游客管理系统，具体实现以下功能：***

***1.电子门票：将RFID技术应用于景区电子门票，实现出票、验票（门禁）、计票等功能。可实现景区“一卡通”功能（选做），游客对电子门票充值后，可以在景区内进行餐饮、旅游项目、购物等一切消费活动。***

***2.定位跟踪：将GPS/北斗定位技术用于游客的定位跟踪，在游客求助时可以迅速确定游客的位置，及时提供帮助；可以对各景点的客流量进行统计，结合电子地图，对景点拥堵的概率、时段和程度进行预报。***

***3.电子围栏：结合电子地图，在重点建筑、景区边界等处设置电子围栏，当游客越过电子围栏时会向游客发出提示信息，并向景区工作人员发出报警信息，以保证景区内人身、财产安全性。***

***4.体温检测：实时监测游客体温，当体温出现异常时，向景区管理处发出报警信息。***

***5.一键求助：游客遇有紧急情况需要帮助时，可以通过终端节点一键求助按键，向景区管理处进行求助。***

***6.数据记录与查询：可以记录和查询近几天游客的相关信息，包括游客基本信息、体温、游览景点数据等。***

***7.完成系统软硬件设计、安装与调试。***

***8.按要求撰写毕业设计论文，完成其它相关任务。*** 

项目是基于物联网的景区管理系统，主要分为两部分，硬件设备和管理员系统。

硬件设备主要完成的功能有：

1.创建景区游客的门票信息，保存到RFID里面

2.采集游客的体温数据 GPS数据

3.通过WiFi的通信方式上传数据 通信协议使用的是mqtt

4.通过设备按键向管理员求助

5.通过蜂鸣器的鸣声次数告知游客一些信息

管理员系统

1.监控平台页面，通过此页面，管理员可以看到游客在景区分布的情况，管理员可以在此页面绘制电子围栏，当游客进入电子围栏，将通过蜂鸣器告知游客

2.数据记录查询，可视化游客在景区的体温变化和轨迹，统计游客的信息

3.游客体温异常，管理员系统会报警

4.统计游客的消费情况

数据采集：

在主循环里面检查发送缓冲区有无数据，接收缓冲区有无数据。这些缓冲区其实就是二维数组arr[num]/[length]【个数+长度】，比如我定义了一个5个100字节长的二维数组，然后我的判别有无数据的方式是通过两个指针，其中一个指针一直指向数组头部，此时假如gps数据采集到了数据后，就会将这个采集到的数据放到我的发送缓冲区里面，另外一个指针会加上我的一个单元长度

1.GPS数据通过串口采集，实际上例程中是通过dma方式采集，但不行，进不去dma传输中断

2.串口采集到的温度数据，如果不准，求平均值

1.遇到的问题，总结：人体红外传感器测量不准，灵敏度调了也还是没什么用，为了解决这个问题，在我采集它的数据的时候，我就连续采集了很多次，只要有一次是有人的，我就当是有人，这个具体多少次当时我是看最终那个效果试出来的

3.在开发的过程中，划分好功能我觉得是很重要的，这样我可以单个功能模块开发，最后只要整合代码就行

首先我先对各个模块烧了下例程，确保模块是正常的，然后，首先进行一个数据方面的打通先，就是先和我的服务器完成通信，确保收发操作如何进行后，我就开始gps模块的开发，整合进来，我服务器就可以收到gps数据了，逐步完善其他模块，最后整合，项目就差不多了



UART通用异步收发器

    UART口指的是一种物理接口形式(硬件)。



    UART是异步，全双工串口总线。它比同步串口复杂很多。有两根线，一根TXD用于发送，一根RXD用于接收。

    UART的串行数据传输不需要使用时钟信号来同步传输，而是依赖于发送设备和接收设备之间预定义的配置，STM32相关实例:按下按键，通过串口发送数据实例。

    对于发送设备和接收设备来说，两者的串行通信配置应该设置为完全相同。



    起始位：表示数据传输的开始，电平逻辑为“0” 。

    数据位：可能值有5、6、7、8、9，表示传输这几个bit 位数据。一般取值为8，因为一个ASCII 字符值为8 位。

    奇偶校验位：用于接收方对接收到的数据进行校验，校验“1” 的位数为偶数(偶校验) 或奇数(奇校验)，以此来校验数据传送的正确性，使用时不需要此位也可以。

    停止位：表示一帧数据的结束。电平逻辑为“1”。

    如果用通用IO口模拟UART总线，则需一个输入口，一个输出口。

I2C总线

    I2C总线是一种同步、半双工双向的两线式串口总线。它由两条总线组成：串行时钟线SCL和串行数据线SDA。

    SCL线——负责产生同步时钟脉冲。

    SDA线——负责在设备间传输串行数据。

    该总线可以将多个I2C设备连接到该系统上。连接到I2C总线上的设备既可以用作主设备，也可以用作从设备。



    主设备负责控制通信，通过对数据传输进行初始化，来发送数据并产生所需的同步时钟脉冲。从设备则是等待来自主设备的命令，并响应命令接收。

    主设备和从设备都可以作为发送设备或接收设备。无论主设备是作为发送设备还是接收设备，同步时钟信号都只能由主设备产生。

    如果用通用IO口模拟I2C总线，并实现双向传输，则需一个输入输出口(SDA)，另外还需一个输出口(SCL)。

SPI串行外设接口

    SPI总线是同步、全双工双向的4线式串行接口总线。它是由“单个主设备+多个从设备”构成的系统。

    在系统中，只要任意时刻只有一个主设备是处于激活状态的，就可以存在多个SPI主设备。常运用于AD转换器、EEPROM、FLASH、实时时钟、数字信号处理器和数字信号解码器之间实现通信。



    为了实现通信，SPI共有4条信号线，分别是：

主设备出、从设备入（Master Out Slave In，MOSI）：由主设备向从设备传输数据的信号线，也称为从设备输入（Slave Input/Slave Data In，SI/SDI）。

主设备入、从设备出（Master In Slave Out，MISO）：由从设备向主设备传输数据的信号线，也称为从设备输出（Slave Output/Slave Data Out，SO/SDO）。

串行时钟（Serial Clock，SCLK）：传输时钟信号的信号线。

从设备选择（Slave Select，SS）：用于选择从设备的信号线，低电平有效。

    SPI 的工作时序模式由CPOL（Clock Polarity，时钟极性）和CPHA（Clock Phase，时钟相位）之间的相位关系决定，CPOL 表示时钟信号的初始电平的状态，CPOL 为0 表示时钟信号初始状态为低电平，为1 表示时钟信号的初始电平是高电平。CPHA 表示在哪个时钟沿采样数据，CPHA 为0 表示在首个时钟变化沿采样数据，而CPHA 为1 则表示在第二个时钟变化沿采样数据。



UART、SPI、I2C比较

I2C线更少，比UART、SPI更为强大，但是技术上也更加麻烦些，因为I2C需要有双向IO的支持，而且使用上拉电阻，抗干扰能力较弱，一般用于同一板卡上芯片之间的通信，较少用于远距离通信。

SPI实现要简单一些，UART需要固定的波特率，就是说两位数据的间隔要相等，而SPI则无所谓，因为它是有时钟的协议。

I2C的速度比SPI慢一点，协议比SPI复杂一点，但是连线也比标准的SPI要少。

UART一帧可以传5/6/7/8位，I2C必须是8位。I2C和SPI都从最高位开始传。

SPI用片选信号选择从机，I2C用地址选择从机。

## 技术栈：express + mongodb + ES6 + MD5

### 功能需求

#### 登录注册、历史记录查询、喜好分析

#### 1.创建项目

1.https://blog.csdn.net/weixin_42490398/article/details/90212418  

先创建github仓库，然后在本地目录git init  本地与远程仓库连接   git remote add *yourf仓库name* *git_url*

拉取远程仓库到本地 git pull scene-admin main   编写代码，提交到本地仓库  git commit -m "first commit"

2.先进入项目根目录，npm init 生成package.json 文件  然后npm install express --save  安装express框架

然后npx express-generator 安装骨架生成器

3.安装mongoose 相当于sequelize  npm install mongoose --save

4.安装加密 encryto command: npm install encryto --save  安装 formidable   安装 time-formater  安装 express-session 

5.mosca的backend可选redis,mongo等，其实现选择了ascoltatori进行了redis，Mongo等适配兼容。于是下载了ascoltatori的源码查看了mongo部分的源码，发现其实现是使用了mongodb的固定集合。固定集合的特点是事先决定了该集合的文档数，容量大小，以及如果超出了容量，则最新数据覆盖掉最早的数据，类似循环队列。源码里面的设定的文档条数是10000条，最大容量是10MB.根据任务书第六条，<u>数据记录与查询：可以记录和查询近几天游客的相关信息，包括游客基本信息、体温、游览景点数据等</u>。 如果按照每个游客一分钟更新一次数据，一天景区接待游客3000个，景区开放时长8个小时，则一天产生的数据量：1 * 60 * 8 * 3000 = 1440000 条数据 假如数据需要查询近3天的，则需要保存三天的数据 5120000条数据。所以还是**在mosca server里面操作mongo比较好。 mosca 还可以采用集成方式放在express里面 ，这其实跟之前通过http请求，进而发起socket连接类似**。

6.将mosca server集成到express 。定义 mosca 暴露 server  将数据插入  查询时聚合查询 索引查询 

MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果 

使用limit 完成分页查询 

#### 2.历史记录查询及喜好分析

1.游客数据查询

- 显示：游客姓名、游客性别、游客体温、游客日期。编辑操作，删除操作。展开后，还有消费过的商品。经纬度生成路径，到过的景点。
- 一页20条数据，也就是20个游客。
- 可以按天查询，数据库只保存了近5天的数据。因为物联网数据的海量性，决定了不可能长时间保存。

2.游客位置分析

分析出游客的景点路径，游客去过的景点次数，停留时间

3.游客消费分析

游客喜欢消费的商品，游客消费最多的价格区间

#### 3.喜好分析的问题

1.游客消费的记录不应该有游客上传，而是由商家设备上传

消费设备通过wifi模块直接上传游客消费记录至express服务器api，api将数据写入消费表

2.单独一个vue组件用于显示游客消费的数据记录【类似订单列表】

这里不需要聚合查询  两种查询方法 

3.保留消费分析，位置分析的功能

### 流程重构

1.游客设备启动，连接mqtt服务器
　　一旦有人来购票，首先启动一个游客设备，设备自动连接服务器。clientId由设备端自己生成并保存。连接服务器后，设备就提示连接成功同时订阅生成门票的topic，之后向售票客户端发送可以出票了的信息。接下来管理员就可以在售票系统中输入门票信息了。
2.门票管理之售票系统生成门票
　　售票系统往设备订阅的生成门票的主题发送数据。需要提供的数据有：游客姓名[不再作为查询依据，哪怕是需要查询某个游客的情况]，游客手机号[作为游客查询依据，唯一标识]，测量游客的体温，位置采取默认值.  以手机号作为唯一标识，不用担心游客姓名的重复。售票系统这里作为一个mqtt客户端。注意：因为需要验票，而且电子门票应该有三个状态：未使用，使用中，已报废，所以在售票时还需要提供一个门票状态的数据。同时它应该展示在售票统计中。【完成出票功能】

17.门票管理之售票统计

​	售票系统在出票后同时向express服务器发起post请求，将门票信息存储至数据库。所以售票统计中可以查看所有已售门票的信息，并且可以按天查询。这样可以让管理员了解一天的销量。【完成任务书的计票功能】

15.验票系统

​	当游客进入景区之前，需要验票才能进入。所以需要验票设备。验票设备获取游客设备的电子标签信息，验证门票的状态，如果是未使用，才能进入，并且将门票的状态改变为使用中。同时上传后端系统api，api插入数据库，当离开景区后，游客的门票状态则改变为已报废【完成验票功能】

/**********************为了节省设备，出票系统，验票系统，消费系统，充值系统全部放于一个另外设备之中，所以这个设备它担任了四种角色，为了演示效果，我打算用按键选择当前的模式（出票模式，验票模式，消费模式，充值模式，通过四个IO口接线高低电平模拟按键效果），四种功能置于另一设备是有道理的，然后，游客设备可以从前端拿到姓名和手机号******************/

通信方式采用http协议

按键1被按下，设备变成出票设备，游客设备启动后发设备的id到mqtt服务器的一个出票主题，售票系统订阅了这个主题，此时售票系统接收后，售票系统就可以出票了。此时，需将游客设备的卡放到售票设备上（按键1被按下，设备变成了售票设备），售票设备寻卡成功后，检查门票缓冲区，写入游客设备。

按键2被按下，设备变成验票设备，验票设备寻卡成功后，将游客设备的门票状态改变为使用中。

按键3被按下，设备变成消费设备，消费设备寻卡成功后，将进行消费的金额发到消费设备，同时存到数据库。

按键4被按下，设备变成充值设备，充值设备寻卡成功后，将前端输入的充值金额发到充值设备，同时存到数据库，充值设备写入卡。

3.开始循环上报数据
　　client.on(message) 保存数据，取消订阅生成门票，写入电子标签。再订阅一些控制主题【提醒游客已进入危险区域，或者某某景点，路段拥堵情况，销毁游客数据等】。此时还不能开启循环上报，必须监控平台早已订阅了创建游客模型，更新游客模型，销毁游客模型等。设备首先往创建游客模型主题【公共主题 无clientId】发了内容，告诉监控平台创建游客模型。接着开始循环上报数据至更新游客模型主题。【实现是在mosca服务器进行数据库的上传，还是在接收的时候上传，如果在前端上传，将会发起大量的http请求，将会消耗前端性能，所以还是在mqtt服务器上传，可以考虑使用主题来实现识别】
4.处理游客紧急求助
　　这个不属于游客定时上报数据的一部分。当游客按下设备的紧急求助键时，按键应该要使用中断触发，一旦触发，立刻调用client.publish()  ，监控平台在这之前已经完成了紧急处理主题的订阅。这里不需要对游客进行单一连接，所以这样即可。监控平台判断是否是紧急处理的主题信息，然后前端语音播放xx紧急求助，位置是xx。同时，监控平台上该游客的点变红【方便管理员查看位置】。【完成游客一键求助功能】

19.监控平台之按身份证锁定游客及特定消息通知【即是按向某个游客发送通知】

​	此功能便于查找某个游客的情况。且根据需要通知游客。

20.监控平台之体温异常

​	三种思路：1.在监控平台的更新游客模型时检测  2.在硬件端检测  3.在数据到达监控平台时检测

后两者时间上差距不大，如果采取硬件端检测，这需要在增加一个主题，会增大mqtt服务器的压力，同时为了提高实时性，则使用第三种方案。一旦数据到达监控平台，在更新游客数据函数中顺便检测体温是否异常。如果异常，语音播放。同时监控平台该游客的点变黄。【如果需要寻找密切接触者，则计算这个游客与其他游客的同一时间点的距离】

21.监控平台之密切接触者

​	当监控平台检测出某个游客体温异常时，监控平台自动计算密切接触者，并弹出排列好的密切接触者的信息。同时有操作按钮，通知这些密切接触者，返回景区入口。

5.监控平台之电子围栏
        监控平台使用了高德地图和对应的api，管理员可以设置景区电子围栏，禁区电子围栏。监控平台更新的频率太快了会影响性能，考虑到真实情况，监控平台5分钟更新一次，游客两分钟更新一次。游客每次更新的记录都被保存到了mongo数据库。在监控平台更新时，同时检查游客的位置是否位于景区电子围栏，或者禁区电子围栏。而且还会检查游客的体温。以上动作有反应的话，监控平台立刻通知游客设备。通知的方法：这里需要明确两个字段的区别，mqtt clientId 和  游客身份证。 mqtt clientId只用于传输层识别，游客身份证用于应用层识别【完成电子围栏功能】

```javascript
mqtt——clientId的作用
例如，在监控平台检测到游客处于景区电子围栏时，监控平台需要通知游客设备，怎么通知，需要用到clientId,游客在未进入循环上报之前，订阅了该游客进入景点的通知主题。这个主题是唯一的，只适合这个游客，保证每个游客唯一性的方法就是在主题中应用clientId
clientId不必每次都传送，

注意：体温异常不仅需要通知游客，还需要通知管理员。即直接this.$message({type: 'warning', message: vistor.name + vistor.idenfication + position + '体温异常' + vistor.bodyTem})
游客身份证的作用

```

6.增加的功能
       距离测试，设置地图显示范围【附加功能】
7.数据管理之游客数据查询
       这个查询查的是每个游客的姓名，身份证，最高体温记录，体温记录（用于生成体温变化图），时间记录等(游客游玩的日期可从时间记录中得到) [想要在设备端组装这些数据不太可能，所以可以考虑在接收处处理，拦截器]

8.充值系统
    	为了促使游客充值，仅在入口处管理员这里才可以充值。同时，剩下的钱可以在出口处管理员这里退还。所以就需要两个管理员。mqtt和express早就启动了，管理员登录管理系统立刻观察。充值系统的流程是，在出票后，管理员询问是否需要充值，而且出去后可以退还。游客选择充值的话，管理员在充值页面进行输入，需要的数据有身份证，姓名，充值金额。[设备之前就已经订阅了自己的充值主题]点击确认后，充值系统先根据身份证向服务器请求拿到这个游客的id，用于组装出这个游客的充值主题，有了游客对应的充值主题就可以往特定的充值主题发送数据进行充值了。充值系统在充值时还订阅了该游客的充值响应主题，用于了解是否充值成功，设备一旦接收到自己订阅的充值主题的数据，就会立刻往充值响应主题发送响应状态，即是充值成功或者失败。充值系统拿到对应的响应状态后提醒管理员是否充值成功，同时将这个充值状态，和之前的姓名，身份证，还有金额，以及生成一个时间，同时存到数据库。



##### 设备状态是一个非常重要的变量：它可以被用来判断各种情况。比如充值时，如果设备的状态是未启用，则不应该充值。充值是在充值系统中填写信息，然后发送至游客设备。如果发送成功【但在这里，如果设备未启用，则发送也不会失败，因为mqtt 服务器能顺利接收】，则充值成功。经过测试，哪怕设备未开启，也会充值成功。

解决方法1：使用设备状态

解决方法2：timeout 增加充值响应部分。 使用这种

验证：启动mqtt server 后端  前端 



点击充值，第一次失败，第二次成功，因为获取clientId是一个异步操作





9.数据管理之充值记录查询 

```javascript
 Model.aggregate([{$match: {size: 'medium'}}, {$group: {_id: "$name", totalQuantity: { $sum: "$quantity" }}}])  // 先匹配，再分组 统计中等尺寸各种品种的披萨的数量
```

​	为了使管理员了解游客的充值情况，在数据管理模块的充值记录查询功能可以对游客的充值记录进行查询，查询的方式有两种，顺序查询和按游客查询。前面充值系统往数据库塞的数据有：姓名，身份证，充值金额，充值时间，充值状态，顺序查询即直接从数据库拿这些记录，注意要分页。按游客查询，即是聚合查询，聚合查询有个问题就是顺序问题，为了确保聚合后的数据有顺序，因为分页显示需要有顺序，所以将聚合结果做时间排序。

```javascript
db.express_info.aggregate([{$match:{"mobile":"18663930231"}},{$group : {_id : "$express_code",date_time:{$first:"$datetime"},express_code:{$first:"$express_code"}, num_tutorial : {$sum : 1}}},{$sort:{"datetime":-1}},{$skip:5},{$limit:5}])
```

充值记录查询组件有两个标签，默认正常显示即是顺序显示，顺序显示时，按照时间排序，保证分页。点击游客显示，即进行聚合查询。改变的是数据源，因为按照聚合查询后的结果是：游客姓名，游客身份证，游客充值金额记录，游客充值时间记录，游客充值状态记录。由聚合的过程可知，三个数组是一一对应的。

10.消费系统

​	这里又涉及到硬件端。消费设备需要跟游客设备进行交互。游客设备的电子标签被消费设备感应，商家根据游客购买的商品，选择对应商品【价格已经确定】，选择数量，计算费用，读取电子标签的剩余金额【电子标签内部存在一个剩余金额变量，每次充值剩余金额加上充值金额，初始为0】，如果剩余金额大于费用，扣费成功，电子标签的剩余金额减去费用，消费设备上传消费数据：游客姓名，游客身份证，游客消费的商品名称，游客消费的金额，游客消费的数量，游客的剩余金额，游客的支付状态，【游客消费的时间】可以考虑服务器生成。消费设备上传数据的通道是，直接post提交到express api

11.数据管理之消费记录查询

​	为了使管理员能够了解游客的消费情况，在数据管理模块的消费记录查询功能可以对游客的消费情况进行查询。查询的方式有两种，顺序查询和按游客查询。前面消费系统往数据库塞的数据有：游客姓名，游客身份证，游客消费的商品名称，商品单价，游客消费的数量，游客的剩余金额，游客的支付状态，游客消费的时间。

```javascript
ConsumeModel = {
    name, // 姓名
    identification, // 身份证
    goodsName, // 商品名称
    goodsNum, // 商品数量
    goodsPrice, // 商品单价
    dateTime, // 购买时间
    status, // 支付状态
    curDeposit // 剩余金额
}
```

12.数据管理之消费分析

​	为了使管理员了解最热门的商品或服务，统计各类商品的消费占比。使用echarts饼图实现。

```javascript
[{value: 12, name: '火腿肠'} , {value: 4, name: '鸡翅'} , {value: 2， name: '钓鱼'}]
// 怎么查询 统计各类商品的数量
数据源：消费表 
查询操作：ConsumeModel.aggregate([
    {$group: {_id: "$goodsName", totalNum: {$sum: "$goodsNum"}}}
])
[
    {
    	goodsName: '火腿肠',
   		totalNum: 12
    },
    {
        goodsName: '鸡翅',
        totalNum: 4
    },
    {
        goodsName: '钓鱼',
        totalNum: 2
    }
]
```

13.数据管理之游客数据查询

​	为了使管理员能够查看游客的历史数据：这里只提供按游客查询，因为这个数据不像消费记录和充值记录一样，它太多了，直接查看某条游客数据意义不大，所以只按游客查询，这样还可以查看一些关键信息。它提供的数据包括：

```javascript
VistorModel = {
    //clientId, // 设备id
    name,	// 姓名
    idenfication,	// 身份证
    bodyTem,	// 体温数组
//    bodyTemMax,	// 最高体温
    position,	// 位置数组  用于显示游客的路径
    dateTime,   // 时间数组 【这是一个时间数组，但是我需要展示的是日期，时间数组用于体温变化图】
}
游客数据库模型



展开行显示体温变化 el-table
去过的景点怎么实现：就是在提醒游客进入的时候，同时上传到后端

1.创建游客模型时发送的数据包括clientId
设备端发送信息至创建游客topic
创建游客的信息
{
    clientId,
    identity,
    name,
    bodyTem,
    position,
    create_time // 在mqtt server生成
}
vistor = {clientId: {identity, name, bodyTem, position}}

然后，在更新游客的信息时，需要使用到clientId找游客  
所以更新时需要上传的信息仅有：clientId, bodyTem, position, 
游客信息的插入不能在前端

```

14.数据管理之位置分析【景点游玩历史查询】  

​	为了不浪费空间【一开始就不应该使用mongoose】，重新考虑位置分析功能。直接不要这个功能，改为游览路径查询。为管理员展示：游客姓名，游客身份证，游客去过的景点，停留的时长，进入时间，离开时间。

```javascript
{
    name: xx,
    identity: xx,
    scenePoint:
    {
        enter_time: xx,
        leave_time: xx,
        time_length: xx
    }
}
```

18.监控平台之景点客流量统计，对景点拥堵的概率、时段和程度进行预报

在监控平台更新时，会判断游客进入了是否进入了景点。这时候，可以使用一个这样的数据结构来表示

```javascript
[{scenePoint1: [vistor1, vistor2, vistor3...]}, {scenePoint2: [vistor10, vistor12...]}]
上述结构用于记录每个景点的游客。什么时候预报？就在监控平台更新时预报。怎样预报？因为这个是对所有游客的通知，所以这个是公共信息，意味着每个游客都有订阅一个这样的主题： /mqtt/vistor/public 监控平台将信息发送至这个主题。 怎样计算拥堵概率？利用游客的数量以及停留时间【该景点游客停留的平均时长】计算拥堵概率。
拥堵即是超出景点的最大容量。假设景点的最大容量maxSize是100人。当现有游客人数达到最大容量的百分之八十。则根据游客的停留时长，未来一个小时将会达到最大容量。这时候提示未来一个小时会出现拥堵的概率是：拥堵概率取决于   当前游客人数，中位数停留时长，游客流入时速，游客流出时速。
首先，一个景点的游客流速只能通过数据分析，它应该趋于一个稳定值，而且停留时长中位数也是一个稳定值，所以综上，出现拥堵概率只取决于当前游客人数/景点最大游客容量。 如果能对游客的流速和停留时长随时分析，那么拥堵概率为： 拥堵概率 = (当前游客 + （游客流入时速-游客流出时速）*1【因为预报按照一个小时来预测】) / 游客最大容量   例如：某景点游客最大容量为100， 当前游客人数为50，游客流速为10，那么未来一小时出现拥堵概率为60%。
最终实现的效果：在监控平台上可以观察到相应景区电子围栏的人数【完成客流量统计功能】。监控平台还会通报，
https://tts.youdao.com/fanyivoice?word={text}&le=zh&keyfrom=speaker-target	使用有道api text就是要预报的内容 当前xx景点游客人数为xx,10点半到11点半时段，预计拥堵概率为70% 
监控平台还将信息发送给游客设备，当有新消息发送至游客设备，游客设备会哔一声，显示在lcd屏幕上【完成对景点拥堵概率、时段和程度的预报的功能】

```



### 通信通道汇总





